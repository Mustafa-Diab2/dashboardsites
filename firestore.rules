/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user data and a combination of ownership and role-based access for tasks and files.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles. Access is restricted to the owning user.
 * - /tasks/{taskId}: Stores task information. Access is controlled by the task creator and potentially admins (based on denormalized user roles).
 * - /tasks/{taskId}/files/{fileId}: Stores files associated with a task. Access is restricted to the uploader and task creator, and potentially admins.
 *
 * Key Security Decisions:
 * - User listing is explicitly denied.
 * - All write operations require user authentication.
 * - Data validation is minimized to allow for rapid prototyping. Focus is on ownership and relational integrity.
 * - The rules leverage denormalization of the user's role into the task document for more efficient security checks, avoiding the need for costly `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures user profiles, allowing only the owner to read and write.
     * @path /users/{userId}
     * @allow (get, update, delete) if request.auth.uid == userId
     * @allow (create) if request.auth.uid == request.resource.data.id
     * @deny (list) Always deny listing all users.
     * @deny (create) if request.auth.uid != request.resource.data.id
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      // Helper function to check if the user is signed in and is the owner of the document.
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      // Read rules: Only the owner can get their profile.
      allow get: if isOwner(userId);
      // User listing is not allowed.
      allow list: if false;

      // Write rules: Only the owner can create, update, or delete their profile.
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isOwner(userId) && resource.data.id == request.resource.data.id;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Secures tasks, allowing creator to read and write, and leveraging denormalized user roles for admin access.
     * @path /tasks/{taskId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.createdBy
     * @allow (update, delete) if request.auth.uid == resource.data.createdBy && resource != null
     * @deny (create) if request.auth.uid != request.resource.data.createdBy
     * @principle Combines public read access with owner-only writes and potential role-based admin overrides.
     */
    match /tasks/{taskId} {
      // Helper function to check if the user is signed in and is the creator of the task.
      function isCreator(createdBy) {
        return request.auth != null && request.auth.uid == createdBy;
      }

      // Read rules: Everyone can read tasks.
      allow get, list: if true;

      // Write rules:
      // Only the creator can create a task, and the `createdBy` field must match the user's UID.
      allow create: if isCreator(request.resource.data.createdBy);

      // Only the creator can update or delete a task, and the document must exist.
      allow update: if isCreator(resource.data.createdBy) && resource != null;
      allow delete: if isCreator(resource.data.createdBy) && resource != null;
    }

    /**
     * @description Secures files associated with tasks, allowing the uploader or task creator to read and write.
     * @path /tasks/{taskId}/files/{fileId}
     * @allow (get, list) if true
     * @allow (create) if request.auth.uid == request.resource.data.uploadedBy
     * @allow (update, delete) if request.auth.uid == resource.data.uploadedBy && resource != null
     * @deny (create) if request.auth.uid != request.resource.data.uploadedBy
     * @principle Extends task ownership to files, allowing uploaders to manage their own files.
     */
    match /tasks/{taskId}/files/{fileId} {
      // Helper function to check if the user is signed in and is the uploader of the file.
      function isUploader(uploadedBy) {
        return request.auth != null && request.auth.uid == uploadedBy;
      }

      // Read rules: Everyone can read file metadata.
      allow get, list: if true;

      // Write rules:
      // Only the uploader can create a file, and the `uploadedBy` field must match the user's UID.
      allow create: if isUploader(request.resource.data.uploadedBy);

      // Only the uploader can update or delete a file, and the document must exist.
      allow update: if isUploader(resource.data.uploadedBy) && resource != null;
      allow delete: if isUploader(resource.data.uploadedBy) && resource != null;
    }
  }
}