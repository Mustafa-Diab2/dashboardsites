/**
 * @description
 * هذا الـ ruleset يفرض نموذج ملكية صارم لبيانات المستخدم وحضور الموظف والمهام،
 * مع إمكانية "أدمن" اختيارية عبر Custom Claims. يدعم مرفقات لكل مهمة (Firestore + Storage)،
 * ويعتمد على التحقق من ملكية الوثيقة لكل عملية قراءة/كتابة.
 *
 * @dataStructure
 *  - /users/{userId}:
 *      ملف المستخدم. المستخدم يقرأ/يكتب ملفه فقط (مع خيار list للمصادّقين لدعم القوائم).
 *  - /attendance/{attendanceId}:
 *      سجل الحضور. المستخدم يقرأ/ينشئ/يحدّث/يحذف سجلاته فقط.
 *  - /tasks/{taskId}:
 *      المهام. كل المصادّقين يقرأوا. الإنشاء/التحديث/الحذف لمالك المهمة (createdBy)،
 *      أو للأدمن (لو مفعّل claims).
 *  - /tasks/{taskId}/files/{fileId}:
 *      ميتاداتا المرفقات. القراءة للمصادّقين، والإنشاء/التعديل/الحذف للرافع فقط
 *      (أو للأدمن لو موجود).
 *
 * @keySecurityDecisions
 *  - users: ملكية ذاتية؛ (اختياري) السماح بالـ list للمصادّقين لدعم Dropdowns.
 *  - attendance: كل قراءة/استعلام يجب أن تكون لسجلات نفس المستخدم (userId == uid).
 *  - tasks: القراءة عامة للمصادّقين؛ الكتابة للـ createdBy أو للأدمن (claims).
 *  - files: الرافع فقط يدير ملفاته؛ القراءة عامة للمصادّقين.
 *
 * @denormalizationForAuthorization
 *  - لا نعتمد على get() داخل القواعد (لتكلفة الأداء)؛ إن لزم "أدمن"، نفضل Custom Claims:
 *    request.auth.token.role == "admin". (تُعيّن عبر Admin SDK).
 *
 * @structuralSegregation
 *  - لا يوجد فصل هيكلي إضافي.
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /* ============================
     * Helper Functions
     * ============================ */
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // اختياري: دعم "أدمن" عبر Custom Claims (role = "admin")
    function isAdmin() {
      return isSignedIn() && (request.auth.token.role == "admin");
    }

    /* ============================
     * Users
     * ============================ */
    /**
     * @description
     * المستخدم يقرأ/ينشئ/يحدّث/يحذف ملفه فقط. (اختياري) السماح بالـ list لكل المصادّقين
     * لدعم الواجهات (Dropdowns/Reports).
     *
     * @path /users/{userId}
     * @allow (create) user123 ينشئ ملفه:
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.id == 'user123'
     * @allow (get/update/delete) لنفس المالك فقط
     * @allow (list) مصادّق فقط (اختياري)
     */
    match /users/{userId} {
      // القراءة الفردية: المالك يقرأ ملفه، أو الأدمن يقرأ أي ملف
      allow get:   if isOwner(userId) || isAdmin();

      // قراءة القائمة: فقط الأدمن يمكنه رؤية قائمة كل المستخدمين
      allow list:  if isAdmin();

      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isOwner(userId) && resource.data.id == request.resource.data.id;
      allow delete: if isOwner(userId);
    }

    /* ============================
     * Attendance
     * ============================ */
    /**
     * @description
     * المستخدم يقرأ/ينشئ/يحدّث/يحذف سجلات حضوره فقط.
     * ملاحظة: أي Query (list) لازم يكون مفلتر بـ where("userId","==", uid)،
     * والقواعد ستضمن أن كل وثيقة في النتيجة تخص نفس المستخدم وإلا سترفض.
     *
     * @path /attendance/{attendanceId}
     * @allow (read)
     *   - resource.data.userId == request.auth.uid
     * @allow (create)
     *   - request.resource.data.userId == request.auth.uid
     * @allow (update/delete)
     *   - resource.data.userId == request.auth.uid
     */
    match /attendance/{attendanceId} {
      // القراءة الفردية: فقط سجلات المستخدم نفسه أو الأدمن
      allow get:    if isSignedIn() && (resource.data.userId == request.auth.uid || isAdmin());

      // قراءة القائمة: نسمح لكل مصادق، لكن التطبيق يجب أن يستخدم where('userId', '==', uid)
      // القواعد ستمنع قراءة أي وثيقة لا تخص المستخدم في get operation
      allow list:   if isSignedIn();

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    /* ============================
     * Tasks
     * ============================ */
    /**
     * @description
     * القراءة مسموحة لكل المصادّقين. الإنشاء/التحديث/الحذف للمالك (createdBy)،
     * أو للأدمن (لو مفعّل claims).
     *
     * @path /tasks/{taskId}
     * @allow (create)
     *   - request.resource.data.createdBy == request.auth.uid
     * @allow (read)
     *   - isSignedIn()
     * @allow (update/delete)
     *   - (resource.data.createdBy == request.auth.uid) || isAdmin()
     */
    match /tasks/{taskId} {
      allow read:   if isSignedIn(); // تغطي get + list
      allow create: if isSignedIn()
                    && request.resource.data.createdBy == request.auth.uid;

      allow update: if isSignedIn()
                    && (resource.data.createdBy == request.auth.uid || isAdmin());

      allow delete: if isSignedIn()
                    && (resource.data.createdBy == request.auth.uid || isAdmin());

      /**
       * @description
       * ميتاداتا المرفقات لكل مهمة.
       * القراءة: للمصادّقين.
       * الإنشاء: للرافع فقط (uploadedBy == uid) + تطابق taskId داخل الوثيقة (سلامة مرجعية).
       * التعديل/الحذف: للرافع أو الأدمن.
       *
       * @path /tasks/{taskId}/files/{fileId}
       */
      match /files/{fileId} {
        allow read:   if isSignedIn(); // تغطي get + list

        allow create: if isSignedIn()
                      && request.resource.data.uploadedBy == request.auth.uid
                      && request.resource.data.taskId == taskId;

        allow update: if isSignedIn()
                      && (resource.data.uploadedBy == request.auth.uid || isAdmin());

        allow delete: if isSignedIn()
                      && (resource.data.uploadedBy == request.auth.uid || isAdmin());
      }
    }

    /* ============================
     * Courses (اختياري—حسب نموذجك السابق)
     * ============================ */
    /**
     * @description
     * المستخدم يقرأ/يحدّث/يحذف دوراته الخاصة فقط. الإنشاء لأي مصادّق بشرط وجود userId.
     *
     * @path /courses/{courseId}
     */
    match /courses/{courseId} {
      // القراءة الفردية: فقط دورات المستخدم نفسه أو الأدمن
      allow get:    if isSignedIn() && (resource.data.userId == request.auth.uid || isAdmin());

      // قراءة القائمة: نسمح لكل مصادق، لكن التطبيق يجب أن يستخدم where('userId', '==', uid)
      allow list:   if isSignedIn();

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }
  }
}
